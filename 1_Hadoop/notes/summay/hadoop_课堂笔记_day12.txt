1. Yarn的资源调度器
  1.0  如何配置使用调度器
        <property>
   
            <name>yarn.resourcemanager.scheduler.class</name>
            <value>org.apache.hadoop.yarn.server.resourcemanager.scheduler.capacity.CapacityScheduler</value>
        </property>
   
  1.1  FIFO  先进先出(目前很少使用甚至不用)
       特点就是每个job排队等待执行，排到队首的先执行,对首的执行不完，后面只能等待.
       存在的比较严重的问题: 大Job会严重拖慢小Job完成的时间.
                              例如队首的job是需要很多资源的大job,后续的job,就算需要很少的资源，但是
			      也需要慢慢等待.

       

  1.2  Capacity Scheduler 容量调度器
       1)可以配置多条队列，每条队列可以设置资源占比
       2)每条队列的队首的job可以同时执行（从侧面解决了大Job拖慢小job完成时间的问题）
       3)每条队列的空闲资源可临时借调给别的队列使用.
       4)每条队列可以设置最小和最大资源占比 
       5)每条队列可以控制访问用户


  1.3  Fair Scheduler 公平调度器
       1)每条队列中的job共享队列的资源，在时间尺度上公平的获取到队列中的资源.

       2)最大最小公平算法: 
         不加权: (关注点是job的个数)
	      有一条队列总资源12个, 有4个job，对资源的需求分别是: job1->1,  job2->2 , job3->6,  job4->5
              第一次算:  12 / 4 = 3 
		job1: 分3 --> 多2个 
		job2: 分3 --> 多1个
		job3: 分3 --> 差3个
		job4: 分3 --> 差2个
	      第二次算: 3 / 2  = 1.5 
                job1: 分1
		job2: 分2
		job3: 分3 --> 差3个 --> 分1.5 --> 最终: 4.5 
		job4: 分3 --> 差2个 --> 分1.5 --> 最终: 4.5 
	      第n次算: 一直算到没有空闲资源


	 加权:  
	     有一条队列总资源16， 有4个job,  对资源的需求分别是: job1->4 ,  job2->2 , job3->10 , job4->4 
					         每个job的权重为: job1->5 ,  job2->8 , job3->1 ,   job4->2	
	     第一次算: 	16 / (5+8+1+2) =  1
	       job1:  分5 --> 多1
	       job2:  分8 --> 多6
	       job3:  分1 --> 少9
	       job4:  分2 --> 少2
             
	     第二次算: 7 / (1+2) = 7/3
	       job1: 分4
	       job2: 分2
	       job3: 分1 --> 分7/3 --> 少
	       job4: 分2 --> 分14/3(4.66) -->多2.66
             第三次算: 
	       job1: 分4
	       job2: 分2
	       job3: 分1 --> 分7/3 --> 分2.66
	       job4: 分4
	          
                                              




