-Scala中下划线用法
	*标识符命名
	*在至简原则中 ，如果函数的参数在函数体中只出现一次，那么参数省略，用下划线代替
	*import导入
		>静态导入，导入类中的静态成员
			import scala.util.control.Breaks._
		>通配符导入，导入某一个包下的所有类
			import java.util._
		>屏蔽某一个类
			import java.sql.{Date=>_,Array=>_,_}
	*在类中声明属性的时候，指定给属性赋默认值
	*在模式匹配，如果case所有都没有匹配
		case _  ，相当于default
				
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-计算机语言发展历史
	-低级语言

	-汇编语言

	-高级语言
		*编译型语言
			C,C++
			多次执行不需要多次编译，不支持跨平台	
		*解释型语言
			JavaScript
			多次执行需要多次解释，支持跨平台	

		*先编译再解释
			.java-->编译javac-->.class-->java不同的操作系统安装对应的JVM对其进行解释执行-->机器指令

			.scala-->编译scalac-->.class-->scala不同的操作系统安装对应的JVM对其进行解释执行-->机器指令

-第一个Scala程序
	object 名称{
		def main(args:Array[String]):Unit={
			//函数体
		}
	}

	*伴生对象  ---伴随伴生类产生的对象
	*在Scala语言中，没有static关键字，通过伴生对象的机制模拟静态实现
	*默认情况下，如果没有显示声明伴生类，会自动生成一个和伴生对象同名的类作为伴生类；
	当然也可以显示定义伴生类；在开发的时候，只要是涉及静态的内容，都应该定义在伴生对象中
	*真生的伴生对象指的是伴生对象所属类中，定义的单例对象。

-变量和常量
	*变量
		var 变量名:数据类型 = 值

	*常量
		val 变量名:数据类型 = 值	

-字符串输出
	*普通的 + 进行连接
	*printf格式化输出
	*保持字符串原样输出  """ """

	*插值字符串  通过$age访问外部变量，在字符串前加s标记

-获取键盘输入
	StdIn

-数据类型
	*Any
		>AnyVal 值类型
			Unit

		>AnyRef 引用类型
			Null

	*Nothing

-运算符
	*==和equals都比较的内容
	*eq比较对象的地址

-流程控制
	*顺序流程
	*分支流程
		>单分支
		>双分支
		>多分支
		>分支是一个整体，在Scala语言中，分支有返回值，返回值就是每个分支体最后一行代码执行的结果。如果每一个分支体返回的数据类型不一致，那么返回它们共同的父类类型。
	*循环流程
		>语法
			for( 变量名：数据类型<- 数组|集合){

			}

-循环中断
	*在Scala中，没有continue和break关键字
	*通过在循环体中进行判断或者循环守卫，模拟continue的功能
	*通过抛出异常处理异常的方式模拟break功能



~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-函数基本语法
	def 函数名(参数列表):返回值类型={
		函数体
	}

-函数和方法的区别
	*函数直接定义在类的下面叫方法
	*方法支持重载和重写；函数不支持重载以及重写

-函数的参数
	*可变长参数
		>参数名:数据类型*
		>一个参数列表中至多只能有一个可变长参数
		>一个参数列表中有多个参数，那么可变长参数必须放在最后

	*参数的默认值
		>在声明函数的时候，可以给函数的形参赋默认值
		>如果一个函数的参数有默认值，那么调用该函数的时候，有默认值的参数可以省略
		>建议：如果一个参数列表中有默认值，可以将其放在最后

	*带名参数
		>在调用函数的时候，指定形参具体是给哪个参数赋值的

-函数的至简原则
	*return可以省略，Scala会使用函数体的最后一行代码作为返回值
	*如果函数体只有一行代码，可以省略花括号
	*返回值类型如果能够推断出来，那么可以省略（:和返回值类型一起省略）
	*如果有return，则不能省略返回值类型，必须指定
	*如果函数明确声明unit，那么即使函数体中使用return关键字也不起作用
	*Scala如果期望是无返回值类型，可以省略等号
	*如果函数无参，但是声明了参数列表，那么调用时，小括号，可加可不加
	*如果函数没有参数列表，那么小括号可以省略，调用时小括号必须省略
	*如果不关心名称，只关心逻辑处理，那么函数名（def）可以省略

-高阶函数
	*函数的高级用法，在Scala中函数是一等公民
	*函数可以作为值进行传递
		>语法
			函数名 _
		>是作为参数传递和作为返回值传递的基础

	*函数可以作为参数进行传递
		>大多数场景是通过匿名函数(lambda)实现
		>好处
			&解耦
			&灵活的扩展函数的功能

	*函数可以作为返回值进行返回
		>一定存在函数的嵌套

		>内层可以访问外层函数的局部变量，如果在面向对象的编程语言中，一个函数想访问另一个函数的局部变量的话，需要通过参数的传递，这样就会形成方法执行链，链上所有的方法都停留在栈内存中，对栈内存压力较大。

		>如果是函数式编程语言，内层可以访问外层函数的局部变量，会自动的延长外层函数局部变量的生命周期，与内层函数形成一个闭合的效果，我们称之为闭包。

		>柯里化
			&将一个参数列表中的多个参数拆分为多个参数列表
				def f1()(){
				
				}
			&好处
				~可以明确清晰表达每一个参数列表的函数

				~简化函数嵌套编写

		>控制抽象
			&值调用
				传递的是执行的结果

			&名调用
				传递的是代码块

-惰性函数
	当函数返回值被声明为lazy时，函数的执行将被推迟，直到我们首次对此取值，该函数才会执行

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-Scala中的package
	*一种和Java一样的包声明方式
		com.atguigu.XXXX

	*另一种，嵌套的包声明方式
		package aaa{
			package bbb{

			}
		}
		>一个源文件中可以定义多个package
		>子包中的类直接使用父包中的属性或者方法，不需要进行导包
		

-对象和类
	*对象
		在自然界中，只要是客观存在的事物都是对象(万物皆对象)

	*类
		>对大量对象共性的抽象
			有什么--属性
			能做什么--方法

		>在Java|Scala语言中，类是创建对象的模板

		>类是客观事物在人脑中的主观反映

	*类的属性
		>默认遵循封装的原则
		>在Scala中，属性和方法默认修饰符是public，属性编译之后默认是private修饰，并提供了设置|获取属性的方法；要想生成符合JavaBean规范的get和set方法，需要在属性上加一个注解@BeanProperty
		

	*Java中的访问权限
	  	private     当前类
	  	default     （默认）当前类、同包的其它类
	  	protected   当前类、同包的其它类、非同包的子类
	  	public      公开
	
	*Scala访问权限
		private为私有权限，只在类的内部和伴生对象中可用
	  	Scala 中属性和方法的默认访问权限为public，但Scala中无public关键字
	  	protected为受保护权限，Scala中受保护权限比Java中更严格，同类、子类可以访问，同包无法访问。
	  	private[包名]增加包访问权限，包名下的其他类也可以使用

-构造器
	*作用
		构建对象
		属性初始化

	*分类
		>主构造器 
			在声明类的同时声明了主构造器

		>辅助构造器
			方法名必须叫this
			在辅助构造器第一行代码，必须直接或者间接调用主构造器
			辅助构造器可以重载

	*构造器参数
		在主构造器中，如果参数没有加任何修饰，那么该参数只是作为局部变量使用
		在主构造器中，如果参数使用var或者val修饰，那么该参数可以作为类的属性使用


-抽象类
	*抽象属性
		属性只有声明，没有赋值
	*抽象方法
		方法只有声明，没有实现
	*在一个类中，如果存在抽象属性或者抽象方法，那么这个类一定是抽象类
	*一个类是抽象类，那么它不一定有抽象属性或者抽象方法
	*抽象类中的抽象内容一般交给子类实现
	*如果子类也实现不了，那么子类也应该定义为抽象类
	*子类重写父类的抽象属性或者抽象方法，那么override关键字可以省略
	*子类重写父类的非抽象属性或者非抽象方法，那么override关键字必须得加
	*子类重写父类的非抽象属性，要求父类的属性必须val修饰
	*子类可以通过super关键字调用父类的方法

-特质
	*定义特质语法
		trait 名称{

		}

	*类和特质的关系  混入
		>没有父类
			类 extends 特质1 with 特质2 .....
		>有父类
			类 extends 父类 with 特质1 with....

	*特质叠加
		class MyClass19 extends OperationDB with OperationHDFS

		第一步：将类混入的第一个特质以及继承关系拿出来，作为临时叠加顺序
				OperationDB-->Operation

		第二步：列出混入的第二个特质的继承关系，放到临时叠加顺序的前面，已经出现的特质不再重复添加
				OperationHDFS-->OperationDB-->Operation

		第三步：将子类放到临时叠加顺序的最前面
				MyClass--> 	OperationHDFS-->	OperationDB-->	Operation
				我的操作是	向HDFS中			向数据库中		插入数据

		注意：super不是表示调用父类中的方法，而是调用叠加顺序中的下一个特质


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-集合
	*Seq(序列)
		有序、可重复

	*Set(集)
		无序、不可重复

	*Map(映射)	
		以键值对的形式存放数据

	*基本上所有的集合都进行如下划分
		>不可变集合
		>可变集合

	*Array以及String都作为集合进行处理（隐式转换）

-集合中常用的方法
	*获取集合长度
		length
	*获取集合大小
		size
	*循环遍历
		foreach
	*迭代器
		iterator
	*生成字符串
		mkString
	*是否包含
		contains
	*获取集合的头
		head
	*获取集合的尾（不是头的就是尾）
		tail
	*集合最后一个数据
		last
	*集合初始数据（不包含最后一个）
		init
	*反转
		reverse
	*取前（后）n个元素
		take|takeRight
	*去掉前（后）n个元素
		drop|dropRight
	*并集
		union
	*交集
		intersect
	*差集
		diff
	*拉链
		zip
	*滑窗
		sliding
	*求和
		sum
	*求乘积
		product
	*最大值
		max
	*最小值
		min
	*排序
		sorted
		sortBy
		sortWith
	*过滤
		filter

	*转化/映射
		map

	*扁平化  将整体拆分为个体的过程
		:::
		flatten

	*扁平映射   map + flatten
		flatMap

	*分组
		groupBy

	*简化（归约）
		reduce

	*折叠
		fold


